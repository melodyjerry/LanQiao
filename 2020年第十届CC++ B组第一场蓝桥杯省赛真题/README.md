# 2020年第十届C/C++ B组第一场蓝桥杯省赛真题

## 第一题：跑步训练（5分）

题目描述
小明要做一个跑步训练。
初始时，小明充满体力，体力值计为 10000 。如果小明跑步，每分钟损耗 600 的体力。如果小明休息，每分钟增加 300 的体力。体力的损耗和增加都是均匀变化的。
小明打算跑一分钟、休息一分钟、再跑一分钟、再休息一分钟……如此循环。如果某个时刻小明的体力到达 0 ，他就停止锻炼。
请问小明在多久后停止锻炼。为了使答案为整数，请以秒为单位输出答案。答案中只填写数，不填写单位。

### 题目分析

首先求出每秒的损耗，之后模拟跑步休息的锻炼过程就可以

### 题目代码

```
ini=10000
second=0
recoverPerMin=300
comsumePerMin=600
while 1:

##    当剩下的 体力不足以跑一分钟时
    if(ini-comsumePerMin<=0):
##        换算成秒为单位
        second=second*60+ini//(comsumePerMin//60)
        break
    else:ini-=comsumePerMin
    second+=1
    ini+=recoverPerMin
    second+=1
print(second)
    
3880
```



## 第二题：纪念日（5分）

### 题目描述

2020 年 7 月 1 日是中国 共 产 党 成立 99 周年纪念日。
中国 共 产 党 成立于 1921 年 7 月 23 日。
请问从 1921 年 7 月 23 日中午 12 时到 2020 年 7 月 1 日中午 12 时一共包含多少分钟？

### 题目分析

先计算1922年到2020 年一共多少天，然后减去多余的天数

### 题目代码

python有库可以调

```
from datetime import datetime

pre=datetime(1921,7,23,12)
now=datetime(2020,7,1,12)

print(((now-pre).days)*24*60)

52038720
```

## 第三题：合并检测（10分）

### 题目描述

新冠疫情由新冠病毒引起，最近在 A 国蔓延，为了尽快控制疫情， A 国准备给大量民众进病毒核酸检测。
然而，用于检测的试剂盒紧缺。

为了解决这一困难，科学家想了一个办法：合并检测。即将从多个人（ k 个）采集的标本放到同一个试剂盒中进行检测。

如果结果为阴性，则说明这 k 个人都是阴性，用一个试剂盒完成了 k 个人的检测。如果结果为阳性，则说明至少有一个人为阳性，需要将这 k 个人的样本全部重新独立检测（从理论上看，如果检测前 k−1 个人都是阴性可以推断出第 k 个人是阳性，但是在实际操作中不会利用此推断，而是将 k 个人独立检测），加上最开始的合并检测，一共使用了 k+1 个试剂盒完成了 k 个人的检测。

A 国估计被测的民众的感染率大概是 1，呈均匀分布。请问 k 取多少能最节省试剂盒？

### 题目分析

没看懂题目

## 第四题：REPEAT 程序（10分）

### 题目描述

本题总分：10 分
附件 prog.txt 中是一个用某种语言写的程序。
其中 REPEAT k 表示一个次数为 k 的循环。循环控制的范围由缩进表达，从次行开始连续的缩进比该行多的（前面的空白更长的）为循环包含的内容。
例如如下片段：

REPEAT 2:
 A = A + 4
  REPEAT 5:
  REPEAT 6:
   A = A + 5
  A = A + 7
 A = A + 8
A = A + 9

该片段中从 A = A + 4 所在的行到 A = A + 8 所在的行都在第一行的循环两次中。
REPEAT 6: 所在的行到 A = A + 7 所在的行都在 REPEAT 5: 循环中。
A = A + 5 实际总共的循环次数是 2 × 5 × 6 = 60 次。
请问该程序执行完毕之后，A 的值是多少？

### 做过了

[https://github.com/ZHKU-Robot/LanQiao-Learning/tree/master/2020%E7%AC%AC%E5%8D%81%E4%B8%80%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9Bpython%E5%A4%A7%E5%AD%A6%E7%BB%84](https://github.com/ZHKU-Robot/LanQiao-Learning/tree/master/2020%E7%AC%AC%E5%8D%81%E4%B8%80%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AF%E7%9C%81%E8%B5%9Bpython%E5%A4%A7%E5%AD%A6%E7%BB%84)

## 第五题：矩阵（15分）

### **题目描述**

 把 1∼2020 放在 2×1010 的矩阵里。要求同一行中右边的比左边大，同一列中下边的比上边的大。一共有多少种方案？
 答案很大，你只需要给出方案数除以 2020 的余数即可。

###  **题目分析**

笑死,根本不会

 **题目代码**



## 第六题：整除序列（15分）

### 题目描述

有一个序列，序列的第一个数是 n，后面的每个数是前一个数整除 2，请输出这个序列中值为正数的项。
【输入格式】
输入一行包含一个整数 n。
【输出格式】
输出一行，包含多个整数，相邻的整数之间用一个空格分隔，表示答案。
【评测用例规模与约定】
对于 80% 的评测用例，1≤n≤109。
对于所有评测用例，1≤n≤1018。

### 题目分析

笑死,送分

```
n=int(input())
while 1:
    t=n//2
    if t>0:
        print(t,end=" ")
    else:
        break
    n//=2

```

## 第八题：走方格（20分）

### 题目描述

在平面上有一些二维的点阵。
这些点的编号就像二维数组的编号一样，从上到下依次为第 1 至第 n 行，从左到右依次为第 1 至第 m 列，每一个点可以用行号和列号来表示。
现在有个人站在第 1 行第 1 列，要走到第 n 行第 m 列。只能向右或者向下走。
注意，如果行号和列数都是偶数，不能走入这一格中。
问有多少种方案。
【输入格式】
输入一行包含两个整数 n, m。
【输出格式】
输出一个整数，表示答案。
【评测用例规模与约定】
对于所有评测用例，1≤n≤30,1≤m≤30。

### 题目分析

这个经典的dp问题,太经典啦! 

上次是用循环,这次试试递归!



```
n,m=map(int,input().split())
##设 dp[i][j] 这个二维数组的意思为
##第 i 行 第 j 列 的格子 有n种方案
##那么,显而易见的是 如果要走到那个格子,他只能从左或者上走到
##所以走到那个格子的走法是他们的和
##即
##dp[i][j]=dp[i-1][j]+dp[i][j-1]
##但是注意到 第0行和第0列有且仅有一种走法,那么全部设置为1

dp=[[1 for col in range(m)] for row in range(n)]
print(dp)
def nextstep(i,j):
    #终止条件
    if i==n or j==m:
        return
    else:
        #判断
        print(i,j)
        dp[i][j]=dp[i-1][j]+dp[i][j-1]
        nextstep(i+(1 if i!=n else 0),j)
        nextstep(i,j+(1 if j!=m else 0))
nextstep(1,1)
for i in range(n):
    print(*dp[i])


[[1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1], [1, 1, 1, 1, 1, 1, 1]]
1 1
2 1
2 2
2 3
2 4
2 5
2 6
1 2
2 2
2 3
2 4
2 5
2 6
1 3
2 3
2 4
2 5
2 6
1 4
2 4
2 5
2 6
1 5
2 5
2 6
1 6
2 6
1 1 1 1 1 1 1
1 2 3 4 5 6 7
1 3 6 10 15 21 28
```

另外付一下链接

https://leetcode-cn.com/problems/unique-paths/

```
# 伪码框架
def robotRun(m,n):
	# 初始状态
    f = [[1] * n] + [[1] + [0] * (n - 1) for _ in range(m - 1)]
    
    # 定义：输入一个终点坐标 (m,n)，返回到终点的走法数量
    def dp(m,n):
        # 做选择，选择向下走和向右走
        for i in range(1, m):
            for j in range(1, n):
                f[i][j] = f[i - 1][j] + f[i][j - 1]
        return f[m - 1][n - 1]
    return dp(m,n)
```



## 第九题：整数拼接（25分）

### 题目描述

给定义个长度为 n 的数组 A1,A2,⋅⋅⋅,An。你可以从中选出两个数 Ai 和 Aj ( i 不等于 j )，然后将 Ai 和 Aj 一前一后拼成一个新的整数。例如 12 和 345 可以拼成 12345 或 34512。注意交换 Ai 和 Aj 的顺序总是被视为 2 种拼法，即便是 Ai=Aj 时。
请你计算有多少种拼法满足拼出的整数是 K 的倍数。
【输入格式】
第一行包含 2 个整数 n 和 K。
第二行包含 n 个整数 A1,A2,⋅⋅⋅,An。
【输出格式】
一个整数代表答案。
【评测用例规模与约定】
对于 30% 的评测用例，1≤n≤1000,1≤K≤20,1≤Ai≤104。
对于所有评测用例，1≤n≤105，1≤K≤105，1≤Ai≤109。

### 题目分析

这题也看上去挺简单的,只要简单的一个遍历就行



### 题目代码

```
n,k=map(int,input().split())
aList=list(map(int,input().split()))
c=0
for i in range(n):
    for j in range(i+1,n):
        # 拼一下数啊
        s1=str(i)+str(j)
        s2=str(j)+str(i)
        if int(s1) % k==0:
            print(s1)
            c+=1
        if  int(s2)%k==0:
            print(s2)
            c+=1

print(c)
```

